<template>
  <div :id="$options.cardData.cardData._id">
    <generator>
      <div slot="generator">
        <tools-tabs current-tool="wordGroups" />
      </div>
      <card-wrapper
        :content-class="{'is-loading': loading}"
        :card-url="generatedCardUrl"
        :header-config="headerConfig"
        :og-config="ogConfig"
      >
        <div slot="info">
          <p v-t="'info.lead'" class="info-text lead"></p>
          <p v-t="'info.methodology'" class="info-text heading"></p>
          <p v-t="'info.text'" class="info-text"></p>
        </div>

        <div id="skupine-besed">
          <text-frame>
            <i18n path="wordgroups-text" tag="p">
              <span place="words">
                <tag
                  v-for="(word, index) in words"
                  :key="index + word"
                  :text="word"
                  @click="removeWord(word)"
                />
                <plus @click="toggleModal(true)" />
              </span>
              <span place="load">
                <load-link
                  :text="$t('load')"
                  @click="loadResults(true)"
                />
              </span>
            </i18n>
            <div class="row extras">
              <div class="col-xs-12">
                <div class="searchfilter-checkbox">
                  <input
                    id="rev"
                    :checked="showRelative"
                    type="checkbox"
                    class="checkbox"
                    @click="changeShowRelative"
                  >
                  <label v-t="'show-relative'" for="rev"></label>
                </div>
              </div>
            </div>
          </text-frame>

          <p-tabs :start-tab="selectedTab" @switch="focusTab">
            <p-tab :label="$t('speakers')">
              <scroll-shadow ref="shadow">
                <div class="results" @scroll="$refs.shadow.check($event.currentTarget)">
                  <bar-chart
                    v-if="results.people.length"
                    :data="showRelative ? resultsRelative.people : results.people"
                    :show-percentage="!showRelative"
                    show-numbers
                    flexible-labels
                  />
                  <empty-circle
                    v-else
                    :text="emptyText"
                  />
                </div>
              </scroll-shadow>
            </p-tab>
            <p-tab :label="$t('parties')">
              <scroll-shadow ref="shadowPS">
                <div class="results" @scroll="$refs.shadowPS.check($event.currentTarget)">
                  <bar-chart
                    v-if="results.parties.length"
                    :data="showRelative ? resultsRelative.parties: results.parties"
                    :show-percentage="!showRelative"
                    show-numbers
                    flexible-labels
                  />
                  <empty-circle
                    v-else
                    :text="emptyText"
                  />
                </div>
              </scroll-shadow>
            </p-tab>
          </p-tabs>

          <modal
            v-if="modalShown"
            :header="$t('input-words')"
            :button="$t('confirm')"
            @close="toggleModal(false)"
            @ok="toggleModal(false, true)"
          >
            <search-field v-model="modalInputText" @enter="toggleModal(false, true)" />
          </modal>
        </div>
      </card-wrapper>
    </generator>
  </div>
</template>

<script>
import axios from 'axios';
import links from 'mixins/links';
import { defaultHeaderConfig } from 'mixins/altHeaders';
import { defaultOgImage } from 'mixins/ogImages';
import stateLoader from 'helpers/stateLoader';
import common from 'mixins/common';
import Generator from 'components/Generator.vue';
import ToolsTabs from 'components/ToolsTabs.vue';
import BarChart from 'components/BarChart.vue';
import EmptyCircle from 'components/EmptyCircle.vue';
import LoadLink from 'components/LoadLink.vue';
import Modal from 'components/Modal.vue';
import Plus from 'components/Plus.vue';
import PTab from 'components/Tab.vue';
import PTabs from 'components/Tabs.vue';
import SearchField from 'components/SearchField.vue';
import Tag from 'components/Tag.vue';
import TextFrame from 'components/TextFrame.vue';
import ScrollShadow from 'components/ScrollShadow.vue';

export default {
  name: 'SkupineBesed',
  components: {
    Generator,
    ToolsTabs,
    BarChart,
    EmptyCircle,
    LoadLink,
    Modal,
    Plus,
    PTab,
    PTabs,
    SearchField,
    Tag,
    TextFrame,
    ScrollShadow,
  },
  mixins: [
    common,
    links,
  ],
  data() {
    const loadFromState = stateLoader(this.$options.cardData.parlaState);

    return {
      data: this.$options.cardData.data,
      emptyText: this.$t('empty-text'),
      headerConfig: defaultHeaderConfig(this),
      ogConfig: defaultOgImage(this),
      showRelative: loadFromState('showRelative') || false,
      modalShown: false,
      modalInputText: '',
      results: {
        people: [],
        parties: [],
      },
      resultsRelative: {
        people: [],
        parties: [],
      },
      selectedTab: loadFromState('selectedTab') || 0,
      words: loadFromState('words') || [],
      loading: false,
    };
  },
  computed: {
    urlParameters() {
      const state = {};
      if (this.words.length > 0) {
        state.words = this.words;
      }
      if (this.selectedTab !== 0) {
        state.selectedTab = this.selectedTab;
      }
      if (this.showRelative) {
        state.showRelative = this.showRelative;
      }
      return state;
    },
    generatedCardUrl() {
      return `${this.url}?${Object.keys(this.urlParameters).length > 0 ? `state=${encodeURIComponent(JSON.stringify(this.urlParameters))}` : ''}`;
    },
  },
  mounted() {
    if (this.words.length) {
      this.loadResults();
    }
  },
  methods: {
    focusTab(tab) {
      this.selectedTab = tab;
    },
    changeShowRelative() {
      this.showRelative = !this.showRelative;
    },
    toggleModal(newState, addWords = false) {
      if (addWords) {
        this.modalInputText
          .split(',')
          .map(word => word.trim())
          .forEach(this.addWord);
      }
      this.modalInputText = '';
      this.modalShown = newState;
    },
    addWord(word) {
      const position = this.words.indexOf(word);
      if (position === -1) {
        this.words.push(word);
      }
    },
    removeWord(word) {
      const position = this.words.indexOf(word);
      if (position > -1) {
        this.words.splice(position, 1);
      }
    },
    loadResults(user) {
      if (this.words.length < 2 || this.loading) {
        if (user) {
          // eslint-disable-next-line no-alert
          alert(this.$t('empty-text'));
        }
        return;
      }

      this.loading = true;

      const query = this.words
        .map(word => (word.indexOf(' ') > -1 ? `"${word}"` : word))
        .map(encodeURIComponent)
        .join('+');

      axios.get(`${this.slugs.urls.isci}/q/${query}`)
        .then((response) => {
          const scoreHigherThanZero = i => i.score > 0;

          const parties = response.data.facet_counts.facet_fields.party_e
            .filter(scoreHigherThanZero)
            .filter(party => party.party.acronym !== 'unknown')
            .map(party => ({
              label: party.party.acronym,
              // eslint-disable-next-line max-len
              value: Number((party.score / (this.data.orgs[party.party.id] / this.data.all_speeches)).toFixed(4) || 0),
              link: this.getPartyLinkSafe(party.party),
            }));

          const people = response.data.facet_counts.facet_fields.speaker_i
            .filter(scoreHigherThanZero)
            .map(person => ({
              label: person.person.name,
              // eslint-disable-next-line max-len
              value: Number((person.score / (this.data.people[person.person.id] / this.data.all_speeches)).toFixed(4)),
              link: this.getPersonLink(person.person),
              portrait: this.getPersonPortrait(person.person),
            }));

          this.resultsRelative = { parties, people };

          const parties2 = response.data.facet_counts.facet_fields.party_e
            .filter(scoreHigherThanZero)
            .filter(party => party.party.acronym !== 'unknown')
            .map(party => ({
              label: party.party.acronym,
              // eslint-disable-next-line max-len
              value: party.score,
              link: this.getPartyLinkSafe(party.party),
            }));

          const people2 = response.data.facet_counts.facet_fields.speaker_i
            .filter(scoreHigherThanZero)
            .map(person => ({
              label: person.person.name,
              // eslint-disable-next-line max-len
              value: person.score,
              link: this.getPersonLink(person.person),
              portrait: this.getPersonPortrait(person.person),
            }));

          this.results = { parties: parties2, people: people2 };

          this.loading = false;
        });
    },
    getPartyLinkSafe(party) {
      return party.id === -1 ? '' : this.getPartyLink(party);
    },
  },
};
</script>

<style lang="scss" scoped>
@import '~parlassets/scss/breakpoints';
@import '~parlassets/scss/colors';

.results {
  height: 400px;
  padding-top: 12px;
  overflow-y: auto;
}

.extras {
  margin: 40px 0 -20px;
}

.searchfilter-checkbox {
  height: 40px;
  text-align: center;

  @include respond-to(mobile) {
    height: auto;
    margin-left: -70px;
    margin-right: -70px;
  }

  label {
    text-align: left;
    margin-bottom: 0;
    width: auto;
  }

  .checkbox + label:before {
    background-color: $background;
  }

  .checkbox + label {
    font-size: 11px;
    color: $font-placeholder;
    white-space: nowrap;
  }
}

#skupine-besed {
  /deep/ .p-tabs .p-tabs-content,
  /deep/ .p-tabs .p-tabs-content .tab-content {
    overflow-y: visible;
    overflow-x: visible;
  }

  .results {
    margin-top: 6px;
  }
}
</style>
